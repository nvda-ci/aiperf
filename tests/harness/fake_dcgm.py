# SPDX-FileCopyrightText: Copyright (c) 2025-2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
"""Fake DCGM endpoint mocking for component integration tests.

This module provides utilities to mock aiohttp requests to DCGM Prometheus
endpoints, returning fake metrics generated by DCGMFaker. It's designed to
work seamlessly with component integration tests without affecting other
HTTP operations (like server metrics endpoints).
"""

from __future__ import annotations

from dataclasses import dataclass
from unittest.mock import AsyncMock, Mock, patch

from tests.aiperf_mock_server.dcgm_faker import DCGMFaker


@dataclass
class DCGMEndpoint:
    """Configuration for a fake DCGM endpoint.

    Attributes:
        url: The DCGM Prometheus metrics endpoint URL (e.g., "http://localhost:9401/metrics").
        gpu_name: GPU model name from DCGMFaker GPU_CONFIGS (e.g., "h100", "h200", "b200").
        num_gpus: Number of GPUs to simulate.
        seed: Random seed for deterministic fake data generation.
        initial_load: Initial GPU load level (0.0=idle, 1.0=max load).
    """

    url: str
    gpu_name: str = "h100"
    num_gpus: int = 2
    seed: int = 42
    initial_load: float = 0.0


class FakeDCGMMocker:
    """Contextual DCGM endpoint mocker that patches aiohttp.ClientSession.

    This class provides a context manager that patches aiohttp.ClientSession.get
    and aiohttp.ClientSession.head to intercept requests to DCGM metrics endpoints
    and return fake data from DCGMFaker instances.

    Usage:
        # Create endpoints configuration
        endpoints = [
            DCGMEndpoint("http://localhost:9401/metrics", gpu_name="h100", num_gpus=2),
            DCGMEndpoint("http://localhost:9402/metrics", gpu_name="h200", num_gpus=4),
        ]

        # Use as context manager
        with FakeDCGMMocker(endpoints) as fakers:
            # Inside this context, all aiohttp requests to DCGM endpoints
            # will return fake metrics from DCGMFaker
            faker = fakers["http://localhost:9401/metrics"]
            faker.set_load(0.8)  # Adjust load dynamically
    """

    def __init__(self, endpoints: list[DCGMEndpoint] | None = None):
        """Initialize the DCGM mocker.

        Args:
            endpoints: List of DCGM endpoints to mock. If None, uses defaults.
        """
        self.endpoints = endpoints or self._default_endpoints()
        self.fakers: dict[str, DCGMFaker] = {}
        self._original_get = None
        self._original_head = None
        self._patches = []

    @staticmethod
    def _default_endpoints() -> list[DCGMEndpoint]:
        """Get default DCGM endpoints for testing.

        Includes both application defaults (9400, 9401) plus additional test endpoint (9402).
        """
        return [
            DCGMEndpoint(
                url="http://localhost:9400/metrics",
                gpu_name="h100",
                num_gpus=2,
                seed=42,
                initial_load=0.3,
            ),
            DCGMEndpoint(
                url="http://localhost:9401/metrics",
                gpu_name="h100",
                num_gpus=2,
                seed=43,
                initial_load=0.3,
            ),
            DCGMEndpoint(
                url="http://localhost:9402/metrics",
                gpu_name="h200",
                num_gpus=2,
                seed=44,
                initial_load=0.3,
            ),
        ]

    def _create_fakers(self) -> None:
        """Create DCGMFaker instances for each endpoint."""
        for endpoint in self.endpoints:
            self.fakers[endpoint.url] = DCGMFaker(
                gpu_name=endpoint.gpu_name,
                num_gpus=endpoint.num_gpus,
                seed=endpoint.seed,
                hostname=f"fake-host-{endpoint.url.split(':')[-1][:4]}",
                initial_load=endpoint.initial_load,
            )

    def _is_dcgm_url(self, url: str) -> bool:
        """Check if URL is a DCGM metrics endpoint."""
        return url in self.fakers or (isinstance(url, str) and url.endswith("/metrics"))

    def _mock_get(self, original_get):
        """Create a mock GET function that intercepts DCGM requests."""

        def mock_get_for_dcgm(self_session, url, **kwargs):
            """Mock GET that only intercepts DCGM metrics URLs.

            Note: This is NOT async - aiohttp's get() returns a context manager,
            not a coroutine. The context manager's __aenter__ is what's async.
            """
            if self._is_dcgm_url(url):
                faker = self.fakers.get(url)
                if faker is None:
                    # Unknown metrics URL - create default faker
                    faker = DCGMFaker(gpu_name="h100", num_gpus=2, seed=42)

                # Create mock response
                mock_response = AsyncMock()
                mock_response.status = 200
                mock_response.text = AsyncMock(return_value=faker.generate())
                mock_response.raise_for_status = Mock(return_value=None)
                mock_response.headers = {
                    "Content-Type": "text/plain; version=0.0.4; charset=utf-8"
                }

                # Return context manager with async __aenter__/__aexit__
                class MockContextManager:
                    async def __aenter__(self):
                        return mock_response

                    async def __aexit__(self, *args):
                        pass

                return MockContextManager()

            # Not a DCGM endpoint - use original implementation
            return original_get(self_session, url, **kwargs)

        return mock_get_for_dcgm

    def _mock_head(self, original_head):
        """Create a mock HEAD function that intercepts DCGM requests."""

        def mock_head_for_dcgm(self_session, url, **kwargs):
            """Mock HEAD that only intercepts DCGM metrics URLs.

            Note: This is NOT async - aiohttp's head() returns a context manager,
            not a coroutine. The context manager's __aenter__ is what's async.
            """
            if self._is_dcgm_url(url):
                # Create mock response for reachability check
                mock_response = AsyncMock()
                mock_response.status = 200
                mock_response.headers = {
                    "Content-Type": "text/plain; version=0.0.4; charset=utf-8"
                }
                mock_response.raise_for_status = AsyncMock()

                # Return context manager with async __aenter__/__aexit__
                class MockContextManager:
                    async def __aenter__(self):
                        return mock_response

                    async def __aexit__(self, *args):
                        pass

                return MockContextManager()

            # Not a DCGM endpoint - use original implementation
            return original_head(self_session, url, **kwargs)

        return mock_head_for_dcgm

    def __enter__(self) -> dict[str, DCGMFaker]:
        """Enter context manager and start mocking."""
        import aiohttp

        # Create fakers
        self._create_fakers()

        # Store original methods
        self._original_get = aiohttp.ClientSession.get
        self._original_head = aiohttp.ClientSession.head

        # Create and apply patches
        get_patch = patch.object(
            aiohttp.ClientSession, "get", self._mock_get(self._original_get)
        )
        head_patch = patch.object(
            aiohttp.ClientSession, "head", self._mock_head(self._original_head)
        )

        self._patches = [get_patch, head_patch]
        for p in self._patches:
            p.__enter__()

        return self.fakers

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Exit context manager and restore original methods."""
        for p in reversed(self._patches):
            p.__exit__(exc_type, exc_val, exc_tb)
        self._patches.clear()
        return False
