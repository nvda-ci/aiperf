#!/usr/bin/env python3
# SPDX-FileCopyrightText: Copyright (c) 2025-2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
"""
Simple YAML-Driven Literal Type Generator
Python 3.10+ | 2026 Modern Architecture

Generates literals.pyi stub files from types.yaml for IDE autocomplete and type checking.

The key insight: .pyi stub files provide static type information that:
1. Pydantic uses for validation at runtime
2. Cyclopts uses for CLI argument parsing and help generation
3. IDEs use for autocomplete and type checking

Usage:
    python tools/generate_literals.py
    python tools/generate_literals.py --dry-run  # Preview without writing
"""

from __future__ import annotations

import argparse
import sys
from pathlib import Path
from typing import Any

try:
    import yaml
except ImportError:
    print("Error: PyYAML is required. Install with: pip install pyyaml")
    sys.exit(1)

# ============================================================================
# Configuration
# ============================================================================

PROJECT_ROOT = Path(__file__).parent.parent
TYPES_YAML = PROJECT_ROOT / "tools" / "types.yaml"
OUTPUT_LITERALS_PYI = PROJECT_ROOT / "src" / "aiperf" / "common" / "literals.pyi"

COPYRIGHT_HEADER = """\
# SPDX-FileCopyrightText: Copyright (c) 2025-2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
"""


# ============================================================================
# Template for Literal Types
# ============================================================================

LITERALS_FILE_HEADER = '''\
# ============================================================================
# AUTO-GENERATED FILE - DO NOT EDIT
# ============================================================================
# Generated by: tools/generate_literals.py
# Source: tools/types.yaml
#
# To regenerate: python tools/generate_literals.py
# ============================================================================
"""
Auto-generated Literal type aliases for IDE autocomplete and type checking.

These types are used by:
- Pydantic for model field validation
- Cyclopts for CLI argument parsing
- IDEs for autocomplete suggestions
- Type checkers (pyright/mypy) for static analysis

Usage:
    from aiperf.common.literals import MessageType, LifecycleState

    def handle_message(msg_type: MessageType) -> None:
        match msg_type:
            case "command": ...
            case "heartbeat": ...
"""

from typing import Literal, TypeAlias
'''

LITERALS_SECTION_TEMPLATE = """
# ============================================================================
# {category_title}
# ============================================================================

{type_definitions}"""


# ============================================================================
# Formatting Utilities
# ============================================================================


def format_literal_values(values: list[str], indent: int = 0) -> str:
    """
    Format values for Literal type with smart multi-line handling.

    Args:
        values: List of string values to format
        indent: Number of spaces to indent (for multi-line)

    Returns:
        Formatted string suitable for Literal[...]
    """
    quoted = [f'"{v}"' for v in values]

    # Single line if short enough
    if len(quoted) <= 3 and sum(len(v) for v in quoted) < 60:
        return ", ".join(quoted)

    # Multi-line formatting with proper indentation
    indent_str = " " * indent
    lines = []

    # Group 3-4 values per line for readability
    values_per_line = 3 if any(len(v) > 20 for v in quoted) else 4

    for i in range(0, len(quoted), values_per_line):
        chunk = quoted[i : i + values_per_line]
        lines.append(", ".join(chunk) + ",")

    # Join lines with proper indentation
    result = (
        "\n"
        + indent_str
        + "    "
        + f"\n{indent_str}    ".join(lines)
        + "\n"
        + indent_str
    )
    return result


# ============================================================================
# YAML Loading
# ============================================================================


def load_yaml(path: Path) -> dict[str, Any]:
    """
    Load YAML file with error handling.

    Args:
        path: Path to YAML file

    Returns:
        Parsed YAML content as dict

    Raises:
        FileNotFoundError: If file doesn't exist
        yaml.YAMLError: If YAML is malformed
    """
    if not path.exists():
        raise FileNotFoundError(f"YAML file not found: {path}")

    try:
        with open(path, encoding="utf-8") as f:
            content = yaml.safe_load(f)
            if content is None:
                return {}
            return content
    except yaml.YAMLError as e:
        raise yaml.YAMLError(f"Error parsing {path}: {e}") from e


# ============================================================================
# Dynamic Type Discovery
# ============================================================================


def discover_metric_tags() -> list[str]:
    """
    Discover metric tags at runtime by importing MetricRegistry.

    Returns:
        Sorted list of metric tag strings
    """
    try:
        # Add project to path
        sys.path.insert(0, str(PROJECT_ROOT / "src"))

        # Import and get all tags
        from aiperf.metrics.metric_registry import MetricRegistry

        tags = MetricRegistry.all_tags()
        return sorted(tags)

    except Exception as e:
        print(f"‚ö†Ô∏è  Warning: Could not discover metric tags: {e}")
        print("    Skipping MetricTag generation")
        return []


def discover_dynamic_types(types_config: dict) -> dict[str, list[str]]:
    """
    Discover dynamic types by calling methods at runtime.

    Args:
        types_config: Configuration dict from types.yaml

    Returns:
        Dict mapping type name to list of discovered values
    """
    dynamic_types = {}

    # Handle MetricTag specially
    metric_tags = discover_metric_tags()
    if metric_tags:
        dynamic_types["MetricTag"] = metric_tags
        print(f"‚úì Discovered {len(metric_tags)} metric tags")

    # Handle other dynamic types from config
    for name, config in types_config.get("dynamic", {}).items():
        if name == "MetricTag":
            continue  # Already handled

        if not isinstance(config, dict):
            continue

        source = config.get("source")
        method = config.get("method")

        if not source or not method:
            print(f"‚ö†Ô∏è  Warning: Skipping {name} - missing source or method")
            continue

        try:
            # Add project to path
            sys.path.insert(0, str(PROJECT_ROOT / "src"))

            # Import the module and get the class
            module_path, class_name = source.rsplit(".", 1)
            module = __import__(module_path, fromlist=[class_name])
            cls = getattr(module, class_name)

            # Call the method
            method_func = getattr(cls, method)
            values = method_func()

            dynamic_types[name] = sorted(values)
            print(f"‚úì Discovered {len(values)} values for {name}")

        except Exception as e:
            print(f"‚ö†Ô∏è  Warning: Could not discover {name}: {e}")

    return dynamic_types


# ============================================================================
# Literals File Generation
# ============================================================================


def generate_type_alias(name: str, values: list[str], allow_str: bool = False) -> str:
    """
    Generate a single Literal type alias.

    Args:
        name: Type alias name
        values: List of literal string values
        allow_str: If True, adds "| str" to allow any string (useful for dynamic types)

    Returns:
        Formatted type alias string
    """
    formatted_values = format_literal_values(values)
    base_literal = f"Literal[{formatted_values}]"

    if allow_str:
        # For dynamic types: allow known values OR any string
        # Wrap in parentheses for multi-line
        if "\n" in formatted_values:
            return f"{name}: TypeAlias = (\n    {base_literal}\n    | str\n)"
        return f"{name}: TypeAlias = {base_literal} | str"
    else:
        # For static types: strict - only listed values
        return f"{name}: TypeAlias = {base_literal}"


def generate_literals_section(
    category: str, type_defs: dict[str, list[str]], is_dynamic: bool = False
) -> str:
    """
    Generate a section of Literal type aliases.

    Args:
        category: Category name (e.g., "lifecycle", "messaging")
        type_defs: Dict mapping type name to list of values
        is_dynamic: If True, generates types that allow any string (for dynamic types)

    Returns:
        Formatted section with all type definitions
    """
    if not type_defs:
        return ""

    # Convert category to title case with spaces
    category_title = " ".join(word.capitalize() for word in category.split("_"))

    # Generate all type definitions
    type_definitions = []
    for name, values in sorted(type_defs.items()):
        if not isinstance(values, list) or not values:
            continue
        # Dynamic types allow any string, static types are strict
        type_def = generate_type_alias(name, values, allow_str=is_dynamic)
        type_definitions.append(type_def)

    if not type_definitions:
        return ""

    return LITERALS_SECTION_TEMPLATE.format(
        category_title=category_title, type_definitions="\n\n".join(type_definitions)
    )


def generate_literals_file(types_config: dict) -> str:
    """
    Generate the complete literals.pyi file content.

    Args:
        types_config: Parsed types.yaml configuration

    Returns:
        Complete file content as string
    """
    sections = [COPYRIGHT_HEADER + LITERALS_FILE_HEADER]

    # Process each category from types.yaml
    for category, type_defs in types_config.items():
        if category in ("plugins", "dynamic"):
            continue  # Handle separately

        if not isinstance(type_defs, dict):
            continue

        section = generate_literals_section(category, type_defs)
        if section:
            sections.append(section)

    # Add dynamic types section - allow any string for flexibility
    dynamic_types = discover_dynamic_types(types_config)
    if dynamic_types:
        section = generate_literals_section(
            "dynamic_runtime_discovered", dynamic_types, is_dynamic=True
        )
        if section:
            sections.append(section)

    return "\n".join(sections) + "\n"


# ============================================================================
# Validation
# ============================================================================


def validate_python_syntax(code: str, filename: str) -> bool:
    """
    Validate that generated code is valid Python.

    Args:
        code: Python code to validate
        filename: Filename for error messages

    Returns:
        True if valid, False otherwise
    """
    try:
        compile(code, filename, "exec")
        return True
    except SyntaxError as e:
        print(f"‚ùå Syntax error in {filename}:")
        print(f"   Line {e.lineno}: {e.msg}")
        return False


# ============================================================================
# Main Generation Logic
# ============================================================================


def main(dry_run: bool = False) -> int:
    """
    Generate literals.pyi file.

    Args:
        dry_run: If True, preview without writing files

    Returns:
        Exit code (0 for success, 1 for error)
    """
    print("=" * 80)
    print("YAML-Driven Literal Type Generator")
    print("=" * 80)

    # Validate paths
    if not TYPES_YAML.exists():
        print(f"‚ùå Error: types.yaml not found at {TYPES_YAML}")
        print("   Please create this file with your type definitions.")
        return 1

    # Load configurations
    print("\nüìñ Loading configurations...")
    try:
        types_config = load_yaml(TYPES_YAML)
    except Exception as e:
        print(f"‚ùå Error loading YAML: {e}")
        return 1

    print(f"‚úì Loaded {TYPES_YAML.name}")

    # Generate literals.pyi
    print("\nüìù Generating literals.pyi...")
    try:
        literals_content = generate_literals_file(types_config)
    except Exception as e:
        print(f"‚ùå Error generating literals: {e}")
        import traceback

        traceback.print_exc()
        return 1

    # Validate syntax
    if not validate_python_syntax(literals_content, "literals.pyi"):
        return 1

    print(f"‚úì Generated valid Python code ({len(literals_content)} bytes)")

    # Write file (or preview)
    if dry_run:
        print("\nüîç DRY RUN - Preview of generated file:")
        print("\n" + "=" * 80)
        print(f"üìÑ {OUTPUT_LITERALS_PYI}")
        print("=" * 80)
        print(literals_content[:1500] + "\n... (truncated)")
    else:
        print("\nüíæ Writing file...")

        # Ensure output directory exists
        OUTPUT_LITERALS_PYI.parent.mkdir(parents=True, exist_ok=True)

        # Write file
        OUTPUT_LITERALS_PYI.write_text(literals_content, encoding="utf-8")
        print(f"‚úì Wrote {OUTPUT_LITERALS_PYI}")

    # Success summary
    print("\n" + "=" * 80)
    print("‚úÖ Literal types generated successfully!")
    print("=" * 80)

    if not dry_run:
        print("\nüì¶ Generated file:")
        print(f"  ‚Ä¢ {OUTPUT_LITERALS_PYI}")
        print("\nüí° How it works:")
        print("   1. The .pyi stub file provides type info to IDEs and type checkers")
        print("   2. No runtime code exists - it's purely for static analysis")
        print(
            "   3. Pydantic/Cyclopts still work with the actual enum types at runtime"
        )
        print("\nüí° Import these types in your code:")
        print("   from aiperf.common.literals import LifecycleState, MessageType")

    return 0


# ============================================================================
# CLI Entry Point
# ============================================================================

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Generate Literal type stubs from YAML configuration",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Preview generated code without writing files",
    )

    args = parser.parse_args()
    sys.exit(main(dry_run=args.dry_run))
