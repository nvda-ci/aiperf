#!/usr/bin/env python3
# SPDX-FileCopyrightText: Copyright (c) 2025-2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
"""Generate all plugin system artifacts from categories.yaml.

This script generates:
- JSON schemas (categories.schema.json, plugins.schema.json)
- Enum files (enums.py, enums.pyi)
- Type overloads in plugins.py

Usage:
    python tools/generate_plugin_artifacts.py [--all] [--schemas] [--enums] [--overloads]
    python tools/generate_plugin_artifacts.py --check  # Check if files are up-to-date
"""

from __future__ import annotations

import argparse
import importlib
import json
import re
import sys
from collections import defaultdict
from pathlib import Path

import yaml

# =============================================================================
# Paths and Constants
# =============================================================================

TOOLS_DIR = Path(__file__).parent
PROJECT_ROOT = TOOLS_DIR.parent
PLUGIN_DIR = PROJECT_ROOT / "src/aiperf/plugin"
SCHEMA_DIR = PLUGIN_DIR / "schema"
CATEGORIES_YAML = PLUGIN_DIR / "categories.yaml"

# Output files
ENUMS_PY = PLUGIN_DIR / "enums.py"
ENUMS_PYI = PLUGIN_DIR / "enums.pyi"
PLUGINS_PY = PLUGIN_DIR / "plugins.py"

# Keys in categories.yaml that are metadata, not plugin categories
METADATA_KEYS = frozenset({"schema_version"})

# Header for generated files
GENERATED_HEADER = (
    "# SPDX-FileCopyrightText: Copyright (c) 2025-2026 NVIDIA CORPORATION & AFFILIATES. All rights reserved.",
    "# SPDX-License-Identifier: Apache-2.0",
    "# =============================================================================",
    "# ⚠️  AUTO-GENERATED FILE - DO NOT EDIT  ⚠️",
    "# Generated by: tools/generate_plugin_artifacts.py",
    "# =============================================================================",
    "# fmt: off",
)

# Common acronyms that should remain uppercase in display names
ACRONYMS = frozenset(
    {"ui", "zmq", "gpu", "api", "cpu", "llm", "json", "yaml", "csv", "id"}
)

# Markers for generated code in plugins.py
IMPORTS_START = "    # <generated-imports>"
IMPORTS_END = "    # </generated-imports>"
OVERLOADS_START = "    # <generated-overloads>"
OVERLOADS_END = "    # </generated-overloads>"


# =============================================================================
# Shared Utilities
# =============================================================================


def load_categories() -> dict[str, dict]:
    """Load categories.yaml, filtering out metadata keys."""
    data = yaml.safe_load(CATEGORIES_YAML.read_text())
    return {
        k: v for k, v in data.items() if k not in METADATA_KEYS and isinstance(v, dict)
    }


def write_if_changed(path: Path, content: str) -> bool:
    """Write file only if content differs. Returns True if written."""
    if path.exists() and path.read_text() == content:
        return False
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content)
    return True


def parse_class_path(class_path: str) -> tuple[str, str]:
    """Split 'module.path:ClassName' into (module, class_name)."""
    if ":" not in class_path:
        raise ValueError(f"Invalid class path (missing ':'): {class_path}")
    return class_path.rsplit(":", 1)


def to_pascal_case(snake_case: str) -> str:
    """Convert snake_case to PascalCase. E.g., 'timing_strategy' -> 'TimingStrategy'."""
    return "".join(
        word.capitalize() for word in snake_case.replace("-", "_").split("_")
    )


def to_enum_member(name: str) -> str:
    """Convert name to UPPER_SNAKE_CASE. E.g., 'timing-strategy' -> 'TIMING_STRATEGY'."""
    return name.upper().replace("-", "_")


def to_display_name(snake_case: str) -> str:
    """Convert snake_case to Title Case with acronyms. E.g., 'zmq_proxy' -> 'ZMQ Proxy'."""
    words = snake_case.replace("-", "_").split("_")
    return " ".join(
        word.upper() if word.lower() in ACRONYMS else word.capitalize()
        for word in words
    )


def replace_between_markers(
    content: str, start: str, end: str, replacement: str
) -> str:
    """Replace content between markers in a file."""
    pattern = re.compile(rf"({re.escape(start)})\n(.*?)({re.escape(end)})", re.DOTALL)
    if not pattern.search(content):
        raise ValueError(f"Markers not found: {start} ... {end}")
    return pattern.sub(rf"\1\n{replacement}\n\3", content)


def iter_categories_with_plugins(builtin_only: bool = False):
    """Yield (name, spec, entries) for categories with enums and registered plugins.

    Args:
        builtin_only: If True, only include builtin plugins (for .py examples).
                      If False, include all plugins (for .pyi stubs).
    """
    from aiperf.plugin import plugins

    categories = load_categories()
    for name, spec in categories.items():
        if not spec.get("enum"):
            continue
        if builtin_only:
            entries = [entry for entry, _ in plugins.iter_all(name) if entry.is_builtin]
        else:
            entries = plugins.list_entries(name)
        if entries:
            yield name, spec, entries


# =============================================================================
# Schema Generation
# =============================================================================


def generate_schemas() -> int:
    """Generate JSON schema files for categories.yaml and plugins.yaml.

    Schema generation is done here rather than in model_json_schema overrides
    to keep all schema customization logic in one place.
    """
    import copy

    from aiperf.plugin.schema import (
        CategoriesManifest,
        CategorySpec,
        PluginsManifest,
        PluginSpec,
    )

    categories = load_categories()

    # ==========================================================================
    # Build categories.schema.json
    # ==========================================================================
    # CategoriesManifest uses extra="allow" for arbitrary category keys.
    # We customize additionalProperties to reference CategorySpec schema.
    categories_schema = CategoriesManifest.model_json_schema()
    category_spec_schema = CategorySpec.model_json_schema()

    # Merge any $defs from CategorySpec into root schema
    if "$defs" in category_spec_schema:
        categories_schema.setdefault("$defs", {}).update(
            category_spec_schema.pop("$defs")
        )

    # Set additionalProperties to CategorySpec schema (not just `true`)
    categories_schema["additionalProperties"] = category_spec_schema

    # ==========================================================================
    # Build plugins.schema.json
    # ==========================================================================
    # PluginsManifest uses extra="allow" for arbitrary category sections.
    # We build per-category schemas with typed metadata where available.
    plugins_schema = PluginsManifest.model_json_schema()
    plugin_entry_schema = PluginSpec.model_json_schema()

    for name, spec in categories.items():
        # Deep copy properties to avoid mutation affecting other categories
        entry_schema = {
            "type": "object",
            "properties": copy.deepcopy(plugin_entry_schema.get("properties", {})),
            "required": list(plugin_entry_schema.get("required", [])),
        }

        category_desc = spec.get("description", "").strip()
        def_name = to_pascal_case(name) + "Plugin"
        display_name = to_display_name(name)
        entry_schema["title"] = f"{display_name} Plugin"
        if category_desc:
            entry_schema["description"] = category_desc

        if metadata_class := spec.get("metadata_class"):
            try:
                mod, cls = parse_class_path(metadata_class)
                metadata_schema = getattr(
                    importlib.import_module(mod), cls
                ).model_json_schema()
                plugins_schema.setdefault("$defs", {}).update(
                    metadata_schema.pop("$defs", {})
                )
                entry_schema["properties"]["metadata"] = metadata_schema
            except Exception:
                pass

        plugins_schema.setdefault("$defs", {})[def_name] = entry_schema
        plugins_schema["properties"][name] = {
            "title": f"{display_name} Plugins",
            "type": "object",
            "description": category_desc,
            "additionalProperties": {"$ref": f"#/$defs/{def_name}"},
        }

    plugins_schema["additionalProperties"] = False

    # ==========================================================================
    # Write schema files
    # ==========================================================================
    schemas = {
        "categories.schema.json": categories_schema,
        "plugins.schema.json": plugins_schema,
    }

    files_written = 0
    for filename, schema in schemas.items():
        schema = {
            "$schema": "https://json-schema.org/draft/2020-12/schema",
            "$id": filename,
            **schema,
        }
        content = json.dumps(schema, indent=2) + "\n"
        if write_if_changed(SCHEMA_DIR / filename, content):
            print(f"  Generated: {SCHEMA_DIR / filename}")
            files_written += 1

    if files_written == 0:
        print("  Schema files are already up-to-date")
    return files_written


# =============================================================================
# Enum Generation
# =============================================================================


def generate_enums_py_content() -> str:
    """Generate enums.py content with dynamic plugins.create_enum() calls."""
    # Get categories with builtin plugins only (for docstring examples)
    category_data = list(iter_categories_with_plugins(builtin_only=True))

    # Collect all exported names for __all__
    exported_names = ["PluginType", "PluginTypeStr"]
    for _name, spec, _entries in category_data:
        enum_name = spec["enum"]
        exported_names.extend([enum_name, f"{enum_name}Str"])

    all_names = ", ".join(f'"{name}"' for name in sorted(exported_names))

    lines = [
        *GENERATED_HEADER,
        '"""Plugin Type Enums - generated dynamically from the plugin registry."""',
        "",
        "from typing import TYPE_CHECKING, TypeAlias",
        "",
        "from aiperf.plugin import plugins",
        "from aiperf.plugin.extensible_enums import create_enum",
        "",
        f"__all__ = [{all_names}]",
        "",
        "# Plugin Protocol Categories",
        "if TYPE_CHECKING:",
        "    from aiperf.plugin.enums import PluginType, PluginTypeStr",
        "else:",
        "    _all_plugin_categories = plugins.list_categories()",
        '    PluginType = create_enum("PluginType", {',
        '        category.replace("-", "_").upper(): category',
        "        for category in _all_plugin_categories",
        "    })",
        "    PluginTypeStr: TypeAlias = str",
        "",
    ]

    for name, spec, entries in category_data:
        enum_name = spec["enum"]
        member = to_enum_member(name)
        examples = ", ".join(
            f"{enum_name}.{to_enum_member(e.name)}"
            for e in sorted(entries, key=lambda x: x.name)[:3]
        )
        lines.extend(
            [
                f"{enum_name}Str: TypeAlias = str",
                f'{enum_name} = plugins.create_enum(PluginType.{member}, "{enum_name}")',
                f'"""Dynamic enum for {name.replace("_", " ")}. Example: {examples}"""',
                "",
            ]
        )

    return "\n".join(lines)


def generate_enums_pyi_content() -> str:
    """Generate enums.pyi type stub content."""
    from aiperf.plugin import plugins

    lines = [
        *GENERATED_HEADER,
        '"""Type stubs for dynamically generated plugin enums."""',
        "",
        "from typing import Literal, TypeAlias",
        "",
        "from aiperf.plugin.extensible_enums import ExtensibleStrEnum",
        "",
        "class PluginType(ExtensibleStrEnum):",
        '    """Dynamic enum for plugin categories."""',
        "",
    ]

    # Generate PluginType enum members
    all_categories = sorted(plugins.list_categories())
    for category in all_categories:
        desc = (
            plugins.get_category_metadata(category)["description"]
            .strip()
            .split("\n")[0]
        )
        lines.extend(
            [
                f'    {to_enum_member(category)} = "{category}"',
                f'    """{desc}"""',
            ]
        )

    lines.extend(
        [
            "",
            "PluginTypeStr: TypeAlias = Literal[",
            "    " + ", ".join(f'"{cat}"' for cat in all_categories),
            "]",
            "",
        ]
    )

    # Generate per-category enum classes (include all plugins for type stubs)
    for name, spec, entries in iter_categories_with_plugins(builtin_only=False):
        enum_name = spec["enum"]
        sorted_entries = sorted(entries, key=lambda x: x.name)

        lines.extend(
            [
                f"class {enum_name}(ExtensibleStrEnum):",
                f'    """Dynamic enum for {name} plugins."""',
                "",
            ]
        )

        for entry in sorted_entries:
            lines.append(f'    {to_enum_member(entry.name)} = "{entry.name}"')
            if entry.description:
                desc = entry.description.strip().split("\n")[0]
                lines.append(f'    """{desc}"""')
        lines.append("")

        names = [e.name for e in sorted_entries]
        quoted = ", ".join(f'"{n}"' for n in names)
        lines.extend([f"{enum_name}Str: TypeAlias = Literal[{quoted}]", ""])

    return "\n".join(lines) + "\n"


def generate_enums() -> int:
    """Generate enums.py and enums.pyi files."""
    files_written = 0

    if write_if_changed(ENUMS_PY, generate_enums_py_content()):
        print(f"  Generated: {ENUMS_PY}")
        files_written += 1

    if write_if_changed(ENUMS_PYI, generate_enums_pyi_content()):
        print(f"  Generated: {ENUMS_PYI}")
        files_written += 1

    if files_written == 0:
        print("  Enum files are already up-to-date")
    return files_written


# =============================================================================
# Overload Generation
# =============================================================================


def generate_imports_content(categories: dict) -> str:
    """Generate import statements for protocols and enum types."""
    imports: dict[str, list[str]] = defaultdict(list)
    imports["typing"].extend(["Literal", "overload"])
    imports["aiperf.plugin.enums"].extend(["PluginType", "PluginTypeStr"])

    for spec in categories.values():
        if protocol := spec.get("protocol"):
            mod, cls = parse_class_path(protocol)
            imports[mod].append(cls)
        # Import enum types for use in name_or_class_path parameter
        if enum_name := spec.get("enum"):
            imports["aiperf.plugin.enums"].append(enum_name)

    lines = ["    # fmt: off", "    # ruff: noqa: I001"]
    for mod in sorted(imports):
        names = ", ".join(sorted(set(imports[mod])))
        lines.append(f"    from {mod} import {names}")
    return "\n".join(lines)


def generate_overloads_content(categories: dict) -> str:
    """Generate @overload decorated function stubs."""
    lines = []
    for name, spec in categories.items():
        protocol = spec.get("protocol", "")
        _, cls = parse_class_path(protocol) if protocol else ("", "")
        ret = f"type[{cls}]" if cls else "type"
        member = to_enum_member(name)
        # Use enum type for name_or_class_path if available, otherwise just str
        enum_name = spec.get("enum")
        name_type = f"{enum_name} | str" if enum_name else "str"
        lines.append("    @overload")
        lines.append(
            f'    def get_class(category: Literal[PluginType.{member}, "{name}"], name_or_class_path: {name_type}) -> {ret}: ...'
        )
        lines.append("    @overload")
        lines.append(
            f'    def iter_all(category: Literal[PluginType.{member}, "{name}"]) -> Iterator[tuple[PluginEntry, {ret}]]: ...'
        )

    lines.append("    @overload")
    lines.append(
        "    def get_class(category: PluginType | PluginTypeStr, name_or_class_path: str) -> type: ..."
    )
    lines.append("    # fmt: on")
    return "\n".join(lines)


def generate_overloads(check_mode: bool = False) -> int:
    """Generate type overloads in plugins.py."""
    categories = load_categories()
    content = PLUGINS_PY.read_text()

    updated = replace_between_markers(
        content, IMPORTS_START, IMPORTS_END, generate_imports_content(categories)
    )
    updated = replace_between_markers(
        updated, OVERLOADS_START, OVERLOADS_END, generate_overloads_content(categories)
    )

    if content == updated:
        print("  Overloads are up-to-date")
        return 0

    if check_mode:
        print("  Overloads are out of date!")
        return -1  # Indicate failure for check mode

    PLUGINS_PY.write_text(updated)
    print(f"  Updated: {PLUGINS_PY}")
    return 1


# =============================================================================
# Main CLI
# =============================================================================


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Generate plugin system artifacts from categories.yaml",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python tools/generate_plugin_artifacts.py          # Generate all
  python tools/generate_plugin_artifacts.py --enums  # Generate only enums
  python tools/generate_plugin_artifacts.py --check  # Verify files are up-to-date
""",
    )
    parser.add_argument(
        "--schemas", action="store_true", help="Generate JSON schema files"
    )
    parser.add_argument("--enums", action="store_true", help="Generate enum files")
    parser.add_argument(
        "--overloads", action="store_true", help="Generate type overloads"
    )
    parser.add_argument(
        "--check",
        action="store_true",
        help="Check if files are up-to-date (exit 1 if not)",
    )
    args = parser.parse_args()

    # Default to --all if no specific generators requested
    run_all = not (args.schemas or args.enums or args.overloads)

    generators = [
        ("Schemas", args.schemas, generate_schemas),
        ("Enums", args.enums, generate_enums),
        ("Overloads", args.overloads, lambda: generate_overloads(args.check)),
    ]

    total_files = 0
    errors = 0
    for name, flag, gen in generators:
        if run_all or flag:
            print(f"=== {name} ===")
            try:
                result = gen()
                if result < 0:
                    errors += 1
                else:
                    total_files += result
            except Exception as e:
                print(f"  Error: {e}")
                errors += 1

    if errors:
        return 1
    if args.check and total_files:
        print(
            f"\n{total_files} file(s) would be updated. Run without --check to apply."
        )
        return 1
    return 0


if __name__ == "__main__":
    sys.exit(main())
